<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Mobile 3D Stick Shooter</title>
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; height: 100%; }
    canvas { display: block; width: 100%; height: 100%; }

    /* Start / Calibration Screen */
    #startScreen {
      position: absolute; top: 0; left: 0;
      width: 100vw; height: 100vh;
      background: rgba(0, 0, 0, 0.85);
      color: #fff; font-family: sans-serif; font-size: 24px;
      display: flex; align-items: center; justify-content: center;
      text-align: center; padding: 20px; z-index: 10;
    }
    #startScreen small { display: block; margin-top: 10px; font-size: 16px; color: #ccc; }

    /* HUD */
    #hud, #health {
      position: absolute; top: 12px;
      color: #fff; font-family: sans-serif; font-size: 18px;
      text-shadow: 0 0 4px rgba(0,0,0,0.7); z-index: 5;
    }
    #hud { right: 12px; }
    #health { left: 12px; }

    /* On-screen Controls */
    #controls {
      position: absolute; bottom: 8px; left: 0; right: 0;
      display: flex; justify-content: space-between;
      pointer-events: none; z-index: 5;
    }
    #arrows {
      margin-left: 12px;
      display: grid;
      grid-template-areas:
        ".    up    ."
        "left down right";
      grid-gap: 8px;
      pointer-events: auto;
    }
    #arrows button {
      width: 14vw; height: 14vw;
      max-width: 70px; max-height: 70px;
      font-size: 24px; border-radius: 8px;
      background: rgba(255,255,255,0.3);
      color: #000; border: none;
    }
    #arrows #up-btn    { grid-area: up;    }
    #arrows #down-btn  { grid-area: down;  }
    #arrows #left-btn  { grid-area: left;  }
    #arrows #right-btn { grid-area: right; }

    #shoot-btn {
      margin-right: 12px;
      width: 18vw; height: 18vw;
      max-width: 90px; max-height: 90px;
      border-radius: 50%;
      background: rgba(255,0,0,0.6);
      color: #fff; font-size: 18px;
      border: none; pointer-events: auto;
    }

    /* Game Over & High Scores */
    #gameOverScreen {
      position: absolute; top: 0; left: 0;
      width: 100vw; height: 100vh;
      background: rgba(0,0,0,0.85);
      color: #fff; font-family: sans-serif;
      display: none; flex-direction: column;
      align-items: center; justify-content: center;
      text-align: center; padding: 20px; z-index: 10;
    }
    #gameOverScreen input, #gameOverScreen button {
      margin: 8px 0; padding: 10px;
      font-size: 16px; border-radius: 6px; border: none;
    }
    #highScoreList {
      margin: 10px 0; padding-left: 20px; text-align: left;
      max-height: 30vh; overflow-y: auto;
    }
  </style>
</head>
<body>
  <!-- Start / Calibration Overlay -->
  <div id="startScreen">
    Tap to Start<br/>
    <small>Allow motion & orientation access</small>
  </div>

  <!-- Game Canvas -->
  <canvas id="gameCanvas"></canvas>

  <!-- HUD -->
  <div id="hud">Score: <span id="score">0</span></div>
  <div id="health">HP: <span id="hp">100</span></div>

  <!-- On-Screen Controls -->
  <div id="controls">
    <div id="arrows">
      <button id="up-btn">↑</button>
      <button id="left-btn">←</button>
      <button id="down-btn">↓</button>
      <button id="right-btn">→</button>
    </div>
    <button id="shoot-btn">Shoot</button>
  </div>

  <!-- Game Over & High Scores -->
  <div id="gameOverScreen">
    <h1>Game Over</h1>
    <p>Your Score: <span id="finalScore">0</span></p>
    <div id="highScores">
      <h2>High Scores</h2>
      <ol id="highScoreList"></ol>
      <input type="text" id="usernameInput" placeholder="Your Name" maxlength="12" />
      <button id="submitScoreBtn">Submit Score</button>
    </div>
    <button id="restartBtn">Restart</button>
  </div>

  <!-- Three.js CDN -->
  <script src="https://unpkg.com/three@0.150.1/build/three.min.js"></script>
  <script>
  (function() {
    // --- Setup ---
    const canvas    = document.getElementById('gameCanvas');
    const scene     = new THREE.Scene();
    const camera    = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer  = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Lights & floor
    scene.add(new THREE.AmbientLight(0xffffff, 0.5));
    const dl = new THREE.DirectionalLight(0xffffff, 0.8);
    dl.position.set(5,10,7);
    scene.add(dl);
    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(200,200),
      new THREE.MeshPhongMaterial({ color: 0x222222 })
    );
    floor.rotation.x = -Math.PI/2;
    scene.add(floor);

    // Game state
    let player, enemies = [], bullets = [];
    let score = 0, health = 100;
    let spawnInterval = 2000, lastSpawn = 0;
    let lastTime = performance.now(), isGameOver = false;

    // Controls
    let tiltX=0, tiltY=0;
    let arrowUp=false, arrowDown=false, arrowLeft=false, arrowRight=false;

    // High scores
    const HIGHSCORES_KEY = 'stickShootHighScores';

    // DOM
    const startScreen     = document.getElementById('startScreen');
    const gameOverScreen  = document.getElementById('gameOverScreen');
    const hudScore        = document.getElementById('score');
    const hudHealth       = document.getElementById('hp');
    const finalScoreEl    = document.getElementById('finalScore');
    const highScoreList   = document.getElementById('highScoreList');
    const usernameInput   = document.getElementById('usernameInput');
    const submitScoreBtn  = document.getElementById('submitScoreBtn');
    document.getElementById('restartBtn')
      .addEventListener('click', () => { resetGame(); gameOverScreen.style.display='none'; requestAnimationFrame(loop); });

    submitScoreBtn.addEventListener('click', () => {
      const name = usernameInput.value.trim() || 'Anon';
      const hs = JSON.parse(localStorage.getItem(HIGHSCORES_KEY)||'[]');
      hs.push({ name, score });
      localStorage.setItem(HIGHSCORES_KEY, JSON.stringify(hs));
      loadHighScores();
      usernameInput.disabled = true;
      submitScoreBtn.disabled = true;
    });

    // Create stick-figure player
    function createPlayer() {
      const g = new THREE.Group();
      const mat = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
      // head
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.4,8,8), mat);
      head.position.y = 2.2; g.add(head);
      // torso
      const torso = new THREE.Mesh(new THREE.CylinderGeometry(0.1,0.1,1.5,8), mat);
      torso.position.y = 1.0; g.add(torso);
      // arms
      const arm = new THREE.CylinderGeometry(0.05,0.05,1,8);
      const la = new THREE.Mesh(arm,mat); la.position.set(-0.75,1.5,0); la.rotation.z=Math.PI/2; g.add(la);
      const ra = la.clone(); ra.position.x=0.75; g.add(ra);
      // gun
      const gun = new THREE.Mesh(new THREE.BoxGeometry(0.6,0.1,0.1), mat);
      gun.position.set(1.25,1.5,0); g.add(gun);
      // legs
      const leg = new THREE.CylinderGeometry(0.05,0.05,1,8);
      const ll = new THREE.Mesh(leg,mat); ll.position.set(-0.2,0.5,0); g.add(ll);
      const rl = ll.clone(); rl.position.x=0.2; g.add(rl);
      return g;
    }

    // Create enemy with big torso, smiley face, ponytail
    function createEnemy() {
      const g = new THREE.Group();
      const mat = new THREE.MeshPhongMaterial({ color: 0xff0000 });
      const faceMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
      // head
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.5,8,8), mat);
      head.position.y = 2.4; g.add(head);
      // eyes
      const eyeG = new THREE.SphereGeometry(0.07,6,6);
      const le = new THREE.Mesh(eyeG,faceMat); le.position.set(-0.15,2.5,0.45); g.add(le);
      const re = le.clone(); re.position.x=0.15; g.add(re);
      // smile
      const smile = new THREE.Mesh(
        new THREE.TorusGeometry(0.3,0.04,6,12,Math.PI), faceMat
      );
      smile.position.set(0,2.3,0.45); smile.rotation.x=Math.PI; g.add(smile);
      // ponytail
      const pony = new THREE.Mesh(new THREE.CylinderGeometry(0.05,0.1,0.6,6), mat);
      pony.position.set(0,2.4,-0.4); pony.rotation.x=Math.PI/2; g.add(pony);
      // wide torso
      const torso = new THREE.Mesh(new THREE.CylinderGeometry(0.2,0.2,1.5,8), mat);
      torso.position.y=1.0; g.add(torso);
      // arms
      const arm2 = new THREE.CylinderGeometry(0.05,0.05,1,8);
      const la2 = new THREE.Mesh(arm2,mat); la2.position.set(-0.9,1.5,0); la2.rotation.z=Math.PI/2; g.add(la2);
      const ra2 = la2.clone(); ra2.position.x=0.9; g.add(ra2);
      // legs
      const leg2 = new THREE.CylinderGeometry(0.05,0.05,1,8);
      const ll2 = new THREE.Mesh(leg2,mat); ll2.position.set(-0.3,0.5,0); g.add(ll2);
      const rl2 = ll2.clone(); rl2.position.x=0.3; g.add(rl2);
      g.scale.set(1.2,1.2,1.2);
      return g;
    }

    // Spawn enemy
    function spawnEnemy() {
      const e = createEnemy();
      const ang = Math.random()*Math.PI*2, dist=50;
      e.position.set(
        player.position.x + Math.cos(ang)*dist,
        0,
        player.position.z + Math.sin(ang)*dist
      );
      e.userData.speed = 1 + score*0.02;
      scene.add(e);
      enemies.push(e);
      spawnInterval = Math.max(500, spawnInterval*0.97);
    }

    // Shoot bullet
    function shoot() {
      if (isGameOver) return;
      const geom = new THREE.SphereGeometry(0.1,8,8);
      const mat  = new THREE.MeshBasicMaterial({ color: 0xffff00 });
      const m = new THREE.Mesh(geom, mat);
      const dir = new THREE.Vector3(
        Math.sin(player.rotation.y), 0, Math.cos(player.rotation.y)
      );
      m.position.copy(player.position)
               .add(dir.clone().multiplyScalar(1.5))
               .add(new THREE.Vector3(0,1.5,0));
      scene.add(m);
      bullets.push({ mesh:m, dir, life:0 });
    }

    // Utility clamp
    function clamp(v, min, max) { return v<min?min:v>max?max:v; }

    // Load high scores
    function loadHighScores() {
      const list = JSON.parse(localStorage.getItem(HIGHSCORES_KEY)||'[]')
        .sort((a,b)=>b.score-a.score).slice(0,10);
      highScoreList.innerHTML = '';
      list.forEach(e=> {
        const li = document.createElement('li');
        li.textContent = `${e.name}: ${e.score}`;
        highScoreList.appendChild(li);
      });
    }

    // Update HUD
    function updateHUD() {
      hudScore.textContent  = score;
      hudHealth.textContent = Math.max(0, health);
    }

    // End game
    function endGame() {
      isGameOver = true;
      finalScoreEl.textContent = score;
      loadHighScores();
      gameOverScreen.style.display = 'flex';
    }

    // Reset game
    function resetGame() {
      enemies.forEach(e=>scene.remove(e));
      bullets.forEach(b=>scene.remove(b.mesh));
      enemies = []; bullets = [];
      score = 0; health = 100;
      spawnInterval = 2000; lastSpawn = performance.now();
      isGameOver = false;
      usernameInput.disabled = false;
      submitScoreBtn.disabled = false;
      usernameInput.value = '';
      updateHUD();
    }

    // Hook up on-screen controls
    [['up','ArrowUp'],['down','ArrowDown'],['left','ArrowLeft'],['right','ArrowRight']]
      .forEach(([dir,key])=>{
        const btn = document.getElementById(`${dir}-btn`);
        btn.addEventListener('touchstart',e=>{ e.preventDefault(); window[`arrow${dir.charAt(0).toUpperCase()+dir.slice(1)}`]=true; });
        btn.addEventListener('touchend',  e=>{ e.preventDefault(); window[`arrow${dir.charAt(0).toUpperCase()+dir.slice(1)}`]=false; });
        btn.addEventListener('mousedown',e=>{ e.preventDefault(); window[`arrow${dir.charAt(0).toUpperCase()+dir.slice(1)}`]=true; });
        btn.addEventListener('mouseup',  e=>{ e.preventDefault(); window[`arrow${dir.charAt(0).toUpperCase()+dir.slice(1)}`]=false; });
        // keyboard fallback
        window.addEventListener('keydown', e=>{ if(e.key===key) window[`arrow${dir.charAt(0).toUpperCase()+dir.slice(1)}`]=true; });
        window.addEventListener('keyup',   e=>{ if(e.key===key) window[`arrow${dir.charAt(0).toUpperCase()+dir.slice(1)}`]=false; });
      });
    document.getElementById('shoot-btn')
      .addEventListener('touchstart', e=>{ e.preventDefault(); shoot(); })
      .addEventListener('mousedown',  e=>{ e.preventDefault(); shoot(); });

    // Device orientation handler
    function onDeviceOrient(e) {
      // adjust tilt relative to initial
      tiltX = clamp((e.gamma  || 0) / 30, -1, 1);
      tiltY = clamp((e.beta   || 0) / 30, -1, 1);
      // use alpha for camera yaw
      const alpha = (e.alpha || 0);
      player.rotation.y = -THREE.MathUtils.degToRad(alpha);
    }

    // Request permission & start
    startScreen.addEventListener('touchstart', async () => {
      // iOS permission
      if (DeviceMotionEvent.requestPermission) {
        try { await DeviceMotionEvent.requestPermission(); }
        catch{} 
      }
      if (DeviceOrientationEvent.requestPermission) {
        try { await DeviceOrientationEvent.requestPermission(); }
        catch{} 
      }
      window.addEventListener('deviceorientation', onDeviceOrient);
      // initialize player & start
      player = createPlayer();
      scene.add(player);
      lastSpawn = performance.now();
      lastTime  = performance.now();
      startScreen.style.display = 'none';
      requestAnimationFrame(loop);
    }, { once: true });

    // Main loop
    function loop(time) {
      const dt = (time - lastTime)/1000;
      lastTime = time;
      if (!isGameOver) {
        // spawn enemies
        if (time - lastSpawn > spawnInterval) {
          spawnEnemy();
          lastSpawn = time;
        }
        // movement vector from tilt + arrows
        let dx = tiltX + (arrowRight?1:0) - (arrowLeft?1:0);
        let dz = tiltY + (arrowUp?1:0)    - (arrowDown?1:0);
        const len = Math.hypot(dx,dz);
        if (len>0) {
          dx/=len; dz/=len;
          const speed = 8;
          player.position.x += dx * speed * dt;
          player.position.z += dz * speed * dt;
        }
        // clamp
        player.position.x = clamp(player.position.x, -50, 50);
        player.position.z = clamp(player.position.z, -50, 50);

        // bullets update
        bullets = bullets.filter(b=>{
          b.mesh.position.add(b.dir.clone().multiplyScalar(40*dt));
          b.life += dt;
          if (b.life>2) { scene.remove(b.mesh); return false; }
          return true;
        });

        // enemies update & collisions
        enemies = enemies.filter(e=>{
          const toP = new THREE.Vector3().subVectors(player.position,e.position).normalize();
          e.position.add(toP.multiplyScalar(e.userData.speed*dt));
          e.rotation.y = Math.atan2(
            player.position.x - e.position.x,
            player.position.z - e.position.z
          );
          // contact
          if (e.position.distanceTo(player.position)<1) {
            health -= 10; updateHUD();
            scene.remove(e); return false;
          }
          // bullet hits
          for (let i=0; i<bullets.length; i++) {
            const bp = bullets[i].mesh.position;
            const exz = new THREE.Vector2(e.position.x,e.position.z);
            const bxz = new THREE.Vector2(bp.x,bp.z);
            if (bxz.distanceTo(exz)<1.2) {
              score++; updateHUD();
              scene.remove(e); scene.remove(bullets[i].mesh);
              bullets.splice(i,1);
              return false;
            }
          }
          return true;
        });

        if (health <= 0) endGame();

        // camera follow
        const offset = new THREE.Vector3(
          -Math.sin(player.rotation.y)*10,
           5,
          -Math.cos(player.rotation.y)*10
        );
        camera.position.copy(player.position).add(offset);
        camera.lookAt(player.position);
      }
      renderer.render(scene,camera);
      if (!isGameOver) requestAnimationFrame(loop);
    }

    // Initial HUD
    updateHUD();
  })();
  </script>
</body>
</html>