<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
  <title>StickShot Mobile</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0d0d0d;
      --primary: #e63946;
      --accent: #f1faee;
      --control-bg: rgba(255,255,255,0.15);
      --overlay-bg: rgba(29,53,87,0.8);
    }
    * { margin:0; padding:0; box-sizing:border-box; font-family:'Poppins',sans-serif; }
    html, body { width:100%; height:100%; overflow:hidden; background:var(--bg); }
    canvas { display:block; width:100%; height:100%; }

    /* Start Overlay */
    #overlay {
      position:absolute; top:0; left:0; width:100%; height:100%;
      background:var(--overlay-bg); backdrop-filter:blur(8px);
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      color:var(--accent); text-align:center; padding:20px; z-index:10;
    }
    #overlay h1 { font-size:48px; font-weight:600; margin-bottom:16px; }
    #overlay p { font-size:20px; }
    #overlay small { font-size:14px; color:rgba(241,250,238,0.7); margin-top:8px; }

    /* HUD */
    #hud-bar {
      position:absolute; top:16px; left:16px; right:16px;
      display:flex; justify-content:space-between; z-index:5;
    }
    .hud-box {
      background:var(--control-bg); backdrop-filter:blur(4px);
      padding:6px 12px; border-radius:8px; color:var(--accent);
      font-size:18px; font-weight:600; text-shadow:0 0 4px rgba(0,0,0,0.7);
    }

    /* On‑screen Controls */
    #controls {
      position:absolute; bottom:16px; left:16px; right:16px;
      display:flex; justify-content:space-between; z-index:5; pointer-events:none;
    }
    #arrows {
      display:grid;
      grid-template-areas:
        ". up ."
        "left down right";
      grid-gap:8px;
      pointer-events:auto;
    }
    #arrows button {
      width:56px; height:56px; background:var(--control-bg); border:none; border-radius:12px;
      display:flex; align-items:center; justify-content:center;
      color:var(--bg); font-size:24px; font-weight:600;
      box-shadow:0 4px 8px rgba(0,0,0,0.4);
      transition:transform 0.1s;
    }
    #arrows button:active { transform:scale(0.9); }
    #up    { grid-area:up; }
    #down  { grid-area:down; }
    #left  { grid-area:left; }
    #right { grid-area:right; }

    #shoot {
      pointer-events:auto;
      width:64px; height:64px; background:var(--primary); border:none; border-radius:32px;
      display:flex; align-items:center; justify-content:center;
      color:var(--accent); font-size:18px; font-weight:600;
      box-shadow:0 4px 8px rgba(0,0,0,0.4);
      transition:transform 0.1s;
    }
    #shoot:active { transform:scale(0.9); }

    /* Game Over / High Scores */
    #gameOver {
      position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
      width:90%; max-width:360px; background:var(--overlay-bg); backdrop-filter:blur(8px);
      padding:24px; border-radius:16px; text-align:center; color:var(--accent);
      display:none; flex-direction:column; align-items:center; z-index:10;
    }
    #gameOver h2 { font-size:36px; margin-bottom:12px; }
    #gameOver p { font-size:20px; margin-bottom:12px; }
    #gameOver ol {
      list-style:none; width:100%; max-height:200px; overflow-y:auto;
      padding:0; margin-bottom:12px;
    }
    #gameOver ol li {
      background:var(--control-bg); border-radius:8px;
      padding:6px; font-size:16px; text-align:left;
      margin-bottom:6px; color:var(--bg);
    }
    #gameOver input {
      width:100%; padding:8px; border:none; border-radius:8px;
      margin-bottom:12px; font-size:16px;
    }
    #gameOver button {
      background:var(--primary); color:var(--accent); border:none;
      border-radius:8px; padding:10px 16px; font-size:18px;
      cursor:pointer; margin-bottom:8px; transition:background 0.2s;
    }
    #gameOver button:hover { background:#d62828; }
  </style>
</head>
<body>
  <div id="overlay">
    <h1>StickShot</h1>
    <p>Tap to Begin</p>
    <small>Allow motion & orientation access</small>
  </div>

  <canvas id="gameCanvas"></canvas>

  <div id="hud-bar">
    <div class="hud-box">HP: <span id="hp">100</span></div>
    <div class="hud-box">Score: <span id="score">0</span></div>
  </div>

  <div id="controls">
    <div id="arrows">
      <button id="up">↑</button>
      <button id="left">←</button>
      <button id="down">↓</button>
      <button id="right">→</button>
    </div>
    <button id="shoot">Shoot</button>
  </div>

  <div id="gameOver">
    <h2>Game Over</h2>
    <p>Your Score: <span id="finalScore">0</span></p>
    <ol id="highScoreList"></ol>
    <input type="text" id="nameInput" placeholder="Your Name" maxlength="12">
    <button id="submitScore">Submit Score</button>
    <button id="restart">Restart</button>
  </div>

  <script src="https://unpkg.com/three@0.150.1/build/three.min.js"></script>
  <script>
  (function(){
    // --- three.js Setup ---
    const canvas   = document.getElementById('gameCanvas');
    const scene    = new THREE.Scene();
    const camera   = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    window.addEventListener('resize',()=>{
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Lights & Floor
    scene.add(new THREE.AmbientLight(0xffffff,0.5));
    const dirLight = new THREE.DirectionalLight(0xffffff,0.8);
    dirLight.position.set(5,10,7);
    scene.add(dirLight);
    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(200,200),
      new THREE.MeshPhongMaterial({ color:0x222222 })
    );
    floor.rotation.x = -Math.PI/2;
    scene.add(floor);

    // --- Game State ---
    let player, enemies = [], bullets = [];
    let score = 0, health = 100;
    let spawnInterval = 2000, lastSpawn = 0;
    let lastTime = 0, isGameOver = false;
    let tiltX = 0, tiltY = 0;
    let arrowUp=false, arrowDown=false, arrowLeft=false, arrowRight=false;

    const HS_KEY = 'stickshotHigh';
    const overlay    = document.getElementById('overlay');
    const gameOverEl = document.getElementById('gameOver');
    const hpEl       = document.getElementById('hp');
    const scoreEl    = document.getElementById('score');
    const finalEl    = document.getElementById('finalScore');
    const listEl     = document.getElementById('highScoreList');
    const nameInput  = document.getElementById('nameInput');
    const submitBtn  = document.getElementById('submitScore');
    const restartBtn = document.getElementById('restart');

    // --- Helpers ---
    function clamp(v,m,M){ return v<m?m:v>M?M:v; }
    function createPlayer(){
      const g=new THREE.Group(), mat=new THREE.MeshPhongMaterial({color:0x00ff00});
      const head=new THREE.Mesh(new THREE.SphereGeometry(0.4,8,8),mat); head.position.y=2.2; g.add(head);
      const torso=new THREE.Mesh(new THREE.CylinderGeometry(0.1,0.1,1.5,8),mat); torso.position.y=1; g.add(torso);
      const armG=new THREE.CylinderGeometry(0.05,0.05,1,8);
      const la=new THREE.Mesh(armG,mat); la.position.set(-0.75,1.5,0); la.rotation.z=Math.PI/2; g.add(la);
      const ra=la.clone(); ra.position.x=0.75; g.add(ra);
      const gun=new THREE.Mesh(new THREE.BoxGeometry(0.6,0.1,0.1),mat); gun.position.set(1.25,1.5,0); g.add(gun);
      const legG=new THREE.CylinderGeometry(0.05,0.05,1,8);
      const ll=new THREE.Mesh(legG,mat); ll.position.set(-0.2,0.5,0); g.add(ll);
      const rl=ll.clone(); rl.position.x=0.2; g.add(rl);
      return g;
    }
    function createEnemy(){
      const g=new THREE.Group(), mat=new THREE.MeshPhongMaterial({color:0xff0000}), fmat=new THREE.MeshBasicMaterial({color:0x000000});
      const head=new THREE.Mesh(new THREE.SphereGeometry(0.5,8,8),mat); head.position.y=2.4; g.add(head);
      const eG=new THREE.SphereGeometry(0.07,6,6);
      const le=new THREE.Mesh(eG,fmat); le.position.set(-0.15,2.5,0.45); g.add(le);
      const re=le.clone(); re.position.x=0.15; g.add(re);
      const smile=new THREE.Mesh(new THREE.TorusGeometry(0.3,0.04,6,12,Math.PI),fmat);
      smile.position.set(0,2.3,0.45); smile.rotation.x=Math.PI; g.add(smile);
      const pony=new THREE.Mesh(new THREE.CylinderGeometry(0.05,0.1,0.6,6),mat);
      pony.position.set(0,2.4,-0.4); pony.rotation.x=Math.PI/2; g.add(pony);
      const torso=new THREE.Mesh(new THREE.CylinderGeometry(0.2,0.2,1.5,8),mat); torso.position.y=1; g.add(torso);
      const armG2=new THREE.CylinderGeometry(0.05,0.05,1,8);
      const la2=new THREE.Mesh(armG2,mat); la2.position.set(-0.9,1.5,0); la2.rotation.z=Math.PI/2; g.add(la2);
      const ra2=la2.clone(); ra2.position.x=0.9; g.add(ra2);
      const legG2=new THREE.CylinderGeometry(0.05,0.05,1,8);
      const ll2=new THREE.Mesh(legG2,mat); ll2.position.set(-0.3,0.5,0); g.add(ll2);
      const rl2=ll2.clone(); rl2.position.x=0.3; g.add(rl2);
      g.scale.set(1.2,1.2,1.2);
      return g;
    }
    function spawnEnemy(){
      const e=createEnemy(), ang=Math.random()*2*Math.PI, d=50;
      e.position.set(player.position.x+Math.cos(ang)*d,0,player.position.z+Math.sin(ang)*d);
      e.userData.speed=1+score*0.02;
      scene.add(e);
      enemies.push(e);
      spawnInterval=Math.max(500,spawnInterval*0.97);
    }
    function shoot(){
      if(isGameOver) return;
      const geom=new THREE.SphereGeometry(0.1,8,8), mat=new THREE.MeshBasicMaterial({color:0xffff00});
      const m=new THREE.Mesh(geom,mat), dir=new THREE.Vector3(Math.sin(player.rotation.y),0,Math.cos(player.rotation.y));
      m.position.copy(player.position).add(dir.clone().multiplyScalar(1.5)).add(new THREE.Vector3(0,1.5,0));
      scene.add(m);
      bullets.push({mesh:m,dir,life:0});
    }
    function updateHUD(){ hpEl.textContent=health; scoreEl.textContent=score; }
    function renderHighScores(){
      const list=JSON.parse(localStorage.getItem(HS_KEY)||'[]').sort((a,b)=>b.score-a.score).slice(0,10);
      listEl.innerHTML='';
      list.forEach(e=>{const li=document.createElement('li');li.textContent=`${e.name}: ${e.score}`;listEl.append(li);});
    }
    function endGame(){
      isGameOver=true;
      finalEl.textContent=score;
      renderHighScores();
      gameOverEl.style.display='flex';
    }
    function resetGame(){
      enemies.forEach(e=>scene.remove(e));
      bullets.forEach(b=>scene.remove(b.mesh));
      enemies=[]; bullets=[];
      score=0; health=100; spawnInterval=2000; lastSpawn=performance.now();
      isGameOver=false; nameInput.disabled=false; submitBtn.disabled=false; nameInput.value='';
      updateHUD();
    }

    // Controls wiring
    [['up','ArrowUp'],['down','ArrowDown'],['left','ArrowLeft'],['right','ArrowRight']].forEach(([id,key])=>{
      const btn=document.getElementById(id);
      btn.addEventListener('pointerdown',()=>window['arrow'+id.charAt(0).toUpperCase()+id.slice(1)]=true);
      btn.addEventListener('pointerup',  ()=>window['arrow'+id.charAt(0).toUpperCase()+id.slice(1)]=false);
      window.addEventListener('keydown', e=>{ if(e.key===key) window['arrow'+id.charAt(0).toUpperCase()+id.slice(1)]=true; });
      window.addEventListener('keyup',   e=>{ if(e.key===key) window['arrow'+id.charAt(0).toUpperCase()+id.slice(1)]=false; });
    });
    document.getElementById('shoot').addEventListener('pointerdown', shoot);

    // Device orientation
    function onOrient(e){
      tiltX = clamp((e.gamma||0)/30, -1, 1);
      tiltY = clamp((e.beta ||0)/30, -1, 1);
      player.rotation.y = -THREE.MathUtils.degToRad(e.alpha||0);
    }

    // Start overlay tap
    overlay.addEventListener('pointerdown', async ()=>{
      // request permissions
      if (DeviceMotionEvent?.requestPermission)  { try{ await DeviceMotionEvent.requestPermission() }catch{} }
      if (DeviceOrientationEvent?.requestPermission) { try{ await DeviceOrientationEvent.requestPermission() }catch{} }
      window.addEventListener('deviceorientation', onOrient);

      // init player
      player = createPlayer();
      scene.add(player);
      lastSpawn = performance.now();
      lastTime  = performance.now();
      overlay.style.display = 'none';
      requestAnimationFrame(loop);
    });

    // Main loop
    function loop(time){
      const dt = (time - lastTime)/1000; lastTime = time;
      if (!isGameOver) {
        if (time - lastSpawn > spawnInterval) { spawnEnemy(); lastSpawn = time; }

        // movement
        let dx = tiltX + (arrowRight?1:0) - (arrowLeft?1:0);
        let dz = tiltY + (arrowUp?1:0)    - (arrowDown?1:0);
        const len = Math.hypot(dx,dz);
        if (len>0) { dx/=len; dz/=len; const s=8; player.position.x += dx*s*dt; player.position.z += dz*s*dt; }
        player.position.x = clamp(player.position.x,-50,50);
        player.position.z = clamp(player.position.z,-50,50);

        // bullets
        bullets = bullets.filter(b=>{
          b.mesh.position.add(b.dir.clone().multiplyScalar(40*dt));
          b.life += dt;
          if (b.life>2) { scene.remove(b.mesh); return false; }
          return true;
        });

        // enemies & collisions
        enemies = enemies.filter(e=>{
          const toP = new THREE.Vector3().subVectors(player.position,e.position).normalize();
          e.position.add(toP.multiplyScalar(e.userData.speed*dt));
          e.rotation.y = Math.atan2(player.position.x-e.position.x, player.position.z-e.position.z);
          if (e.position.distanceTo(player.position)<1) {
            health-=10; updateHUD(); scene.remove(e); return false;
          }
          for (let i=0; i<bullets.length; i++){
            const bp=bullets[i].mesh.position;
            const exz=new THREE.Vector2(e.position.x,e.position.z), bxz=new THREE.Vector2(bp.x,bp.z);
            if (bxz.distanceTo(exz)<1.2){
              score++; updateHUD();
              scene.remove(e); scene.remove(bullets[i].mesh); bullets.splice(i,1);
              return false;
            }
          }
          return true;
        });

        if (health<=0) endGame();

        // camera follow
        const off=new THREE.Vector3(-Math.sin(player.rotation.y)*10,5,-Math.cos(player.rotation.y)*10);
        camera.position.copy(player.position).add(off);
        camera.lookAt(player.position);
      }

      renderer.render(scene,camera);
      if (!isGameOver) requestAnimationFrame(loop);
    }

    updateHUD();
  })();
  </script>
</body>
</html>