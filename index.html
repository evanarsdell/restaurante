<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>3D Space Shooter</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: sans-serif; background: #000; }
    canvas { display: block; }
    #hud {
      position: absolute; top: 10px; left: 10px; right: 10px;
      display: flex; justify-content: space-between;
      color: #fff; z-index: 1; pointer-events: none;
    }
    #score { font-size: 1.2em; }
    #healthContainer {
      width: 40%; background: #333; border-radius: 4px; overflow: hidden;
    }
    #healthBar {
      width: 100%; height: 1em; background: #0f0;
    }
    #gameOver {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.85); color: #fff;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      font-size: 2em; visibility: hidden; z-index: 2;
    }
    #restartButton {
      margin-top: 1em; padding: 0.5em 1em; font-size: 1em; cursor: pointer;
      pointer-events: auto;
    }
  </style>
  <script type="application/manifest+json">
  {
    "name": "3D Space Shooter",
    "short_name": "SpaceShooter",
    "start_url": ".",
    "display": "fullscreen",
    "orientation": "portrait",
    "background_color": "#000000"
  }
  </script>
</head>
<body>
  <div id="hud">
    <div id="score">Score: 0</div>
    <div id="healthContainer"><div id="healthBar"></div></div>
  </div>
  <div id="gameOver">
    Game Over
    <button id="restartButton">Restart</button>
  </div>

  <!-- Three.js from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

  <script>
  // === Globals ===
  let scene, camera, renderer, ship;
  let instancedAsteroids, asteroidsData = [];
  let bullets = [];
  const maxAsteroids = 20;
  const moveSpeed = 10;
  const bulletSpeed = 80;
  const shootInterval = 500;
  let lastShot = 0;

  let moveX = 0, thrust = 0;   // touch inputs
  let tiltX = 0;               // accelerometer
  let score = 0, health = 100;
  let gameOver = false;

  // === Initialization ===
  function init() {
    scene = new THREE.Scene();

    // Starfield background
    const starsGeo = new THREE.BufferGeometry();
    const starCount = 1000;
    const positions = new Float32Array(starCount * 3);
    for (let i = 0; i < starCount; i++) {
      positions[3 * i]     = (Math.random() - 0.5) * 800;
      positions[3 * i + 1] = (Math.random() - 0.5) * 800;
      positions[3 * i + 2] = (Math.random() - 0.5) * 800;
    }
    starsGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    scene.add(new THREE.Points(starsGeo, new THREE.PointsMaterial({ color: 0x888888 })));

    // Camera
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 2, 5);

    // Renderer
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // Lights
    scene.add(new THREE.AmbientLight(0xffffff, 0.5));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
    dirLight.position.set(5, 10, 7.5);
    scene.add(dirLight);

    // Player ship
    const shipGeo = new THREE.BoxGeometry(1, 0.5, 2);
    const shipMat = new THREE.MeshStandardMaterial({ color: 0x00ffcc });
    ship = new THREE.Mesh(shipGeo, shipMat);
    scene.add(ship);

    // Asteroids as InstancedMesh
    const astGeo = new THREE.SphereGeometry(1, 8, 8);
    const astMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
    instancedAsteroids = new THREE.InstancedMesh(astGeo, astMat, maxAsteroids);
    scene.add(instancedAsteroids);
    initAsteroids();

    // Event listeners
    window.addEventListener('resize', onWindowResize);
    window.addEventListener('deviceorientation', onDeviceOrientation);
    document.addEventListener('touchstart', onTouch);
    document.addEventListener('touchmove', onTouch);
    document.addEventListener('touchend', onTouchEnd);
    document.getElementById('restartButton').addEventListener('click', resetGame);

    animate();
  }

  function initAsteroids() {
    asteroidsData.length = 0;
    for (let i = 0; i < maxAsteroids; i++) {
      spawnAsteroid(i);
    }
  }

  function spawnAsteroid(i) {
    const data = {
      pos: new THREE.Vector3(
        (Math.random() - 0.5) * 10,
        (Math.random() - 0.5) * 6,
        - (50 + Math.random() * 50)
      ),
      vel: new THREE.Vector3(0, 0, (1 + Math.random()) * 20),
      scale: 0.5 + Math.random() * 1,
      matrix: new THREE.Matrix4()
    };
    data.matrix.compose(data.pos, new THREE.Quaternion(), new THREE.Vector3(data.scale, data.scale, data.scale));
    instancedAsteroids.setMatrixAt(i, data.matrix);
    asteroidsData[i] = data;
    instancedAsteroids.instanceMatrix.needsUpdate = true;
  }

  function resetGame() {
    score = 0; health = 100; gameOver = false;
    document.getElementById('gameOver').style.visibility = 'hidden';
    initAsteroids();
    bullets.forEach(b => scene.remove(b.mesh));
    bullets = [];
    lastShot = 0;
    ship.position.set(0, 0, 0);
  }

  // === Input Handlers ===
  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function onDeviceOrientation(e) {
    // gamma: left-to-right tilt in degrees [-90,90]
    tiltX = THREE.MathUtils.clamp(e.gamma / 45, -1, 1);
    ship.rotation.z = -tiltX * 0.5;
  }

  let touches = {};
  function onTouch(e) {
    e.preventDefault();
    for (const t of e.changedTouches) {
      touches[t.identifier] = { x: t.clientX, y: t.clientY };
    }
    updateTouchInput();
  }
  function onTouchEnd(e) {
    e.preventDefault();
    for (const t of e.changedTouches) {
      delete touches[t.identifier];
    }
    updateTouchInput();
  }
  function updateTouchInput() {
    moveX = 0;
    thrust = 0;
    const w = window.innerWidth, h = window.innerHeight;
    Object.values(touches).forEach(t => {
      if (t.x > w / 2) {
        // right half: forward/back
        thrust += t.y < h / 2 ? 1 : -1;
      } else {
        // left half: left/right
        moveX += (t.x - w / 4) / (w / 4);
      }
    });
    thrust = THREE.MathUtils.clamp(thrust, -1, 1);
    moveX = THREE.MathUtils.clamp(moveX, -1, 1);
  }

  // === Shooting ===
  function spawnBullet() {
    const dir = new THREE.Vector3();
    ship.getWorldDirection(dir);
    const pos = ship.position.clone().add(dir.clone().multiplyScalar(2));
    const geom = new THREE.SphereGeometry(0.1, 6, 6);
    const mat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
    const mesh = new THREE.Mesh(geom, mat);
    mesh.position.copy(pos);
    scene.add(mesh);
    bullets.push({ mesh, vel: dir.clone().multiplyScalar(bulletSpeed) });
  }

  // === Damage & Game Over ===
  function takeDamage() {
    health -= 20;
    if (health <= 0) endGame();
  }
  function endGame() {
    gameOver = true;
    document.getElementById('gameOver').style.visibility = 'visible';
  }

  // === Main Loop ===
  let prevTime = performance.now();
  function animate() {
    requestAnimationFrame(animate);
    const now = performance.now();
    const dt = (now - prevTime) / 1000;
    prevTime = now;

    if (!gameOver) {
      // Move ship
      ship.position.x = THREE.MathUtils.clamp(ship.position.x + moveX * moveSpeed * dt, -5, 5);
      ship.position.z = THREE.MathUtils.clamp(ship.position.z + thrust * moveSpeed * dt, -10, 2);

      // Auto-shoot
      if (now - lastShot > shootInterval) {
        spawnBullet();
        lastShot = now;
      }

      // Update bullets
      bullets = bullets.filter(b => {
        b.mesh.position.addScaledVector(b.vel, dt);
        if (b.mesh.position.length() > 200) {
          scene.remove(b.mesh);
          return false;
        }
        return true;
      });

      // Update asteroids & collisions
      asteroidsData.forEach((d, i) => {
        d.pos.addScaledVector(d.vel, -dt);

        // Ship collision
        if (d.pos.distanceTo(ship.position) < 1.5) {
          takeDamage();
          spawnAsteroid(i);
        } else {
          // Bullet collisions
          bullets.forEach((b, bi) => {
            if (b.mesh.position.distanceTo(d.pos) < 1) {
              score++;
              spawnAsteroid(i);
              scene.remove(b.mesh);
              bullets.splice(bi, 1);
            }
          });
        }

        // If passed ship
        if (d.pos.z > 5) {
          spawnAsteroid(i);
        }

        // Update instance matrix
        d.matrix.compose(d.pos, new THREE.Quaternion(), new THREE.Vector3(d.scale, d.scale, d.scale));
        instancedAsteroids.setMatrixAt(i, d.matrix);
      });
      instancedAsteroids.instanceMatrix.needsUpdate = true;

      // Camera follow
      const targetPos = ship.position.clone().add(new THREE.Vector3(0, 2, 5));
      camera.position.lerp(targetPos, 0.1);
      camera.lookAt(ship.position);

      // Update HUD
      document.getElementById('score').textContent = 'Score: ' + score;
      document.getElementById('healthBar').style.width = health + '%';
    }

    renderer.render(scene, camera);
  }

  // Start
  init();
  </script>
</body>
</html>