<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <title>Sexy 3D Shooter</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; touch-action: none; }
    canvas { display: block; }

    /* HUD */
    #hud {
      position: absolute; top: 20px; left: 20px;
      color: #0f0; font-family: 'Orbitron', sans-serif;
      font-size: 18px; text-shadow: 0 0 8px rgba(0,255,0,0.7);
      z-index: 10;
    }
    #hud span { margin-right: 30px; }

    /* Game Over */
    #gameover {
      position: absolute; top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      color: #f00; font-family: 'Orbitron', sans-serif;
      font-size: 48px; text-align: center;
      display: none; z-index: 20;
    }
    #gameover button {
      margin-top: 20px; padding: 12px 24px;
      font-size: 20px; border: none; border-radius: 6px;
      background: #f00; color: #000; cursor: pointer;
      text-shadow: 0 0 4px #000;
    }

    /* Joystick */
    #joystickContainer {
      position: absolute; bottom: 20px; left: 20px;
      width: 120px; height: 120px; z-index: 15;
    }
    #joystickBase {
      position: absolute; width: 100%; height: 100%;
      border-radius: 50%; background: rgba(255,255,255,0.1);
      border: 2px solid rgba(255,255,255,0.3);
    }
    #joystickThumb {
      position: absolute; width: 48px; height: 48px;
      top: 36px; left: 36px;
      border-radius: 50%; background: rgba(0,255,255,0.7);
      box-shadow: 0 0 12px rgba(0,255,255,0.9);
      touch-action: none;
    }

    /* Shoot button */
    #shootButton {
      position: absolute; bottom: 40px; right: 20px;
      width: 100px; height: 100px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #f00, #800);
      border: 4px solid #fff;
      font-family: sans-serif; font-size: 18px; color: #fff;
      text-shadow: 0 0 4px #000;
      display: flex; align-items: center; justify-content: center;
      z-index: 15;
      touch-action: none;
    }
    #shootButton:active {
      transform: scale(0.9);
    }
  </style>
</head>
<body>
  <!-- HUD -->
  <div id="hud">
    <span id="score">Score: 0</span>
    <span id="health">Health: 100</span>
  </div>
  <!-- Game Over Overlay -->
  <div id="gameover">
    GAME OVER
    <br>
    <button id="restart">Restart</button>
  </div>
  <!-- Virtual Joystick -->
  <div id="joystickContainer">
    <div id="joystickBase"></div>
    <div id="joystickThumb"></div>
  </div>
  <!-- Fire Button -->
  <div id="shootButton">FIRE</div>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
  <script>
  let scene, camera, renderer;
  let ship, bullets = [], enemies = [], starField;
  let lastEnemyTime = 0, score = 0, health = 100, gameOver = false;
  // Joystick state
  let stickX = 0, stickY = 0, pointerId = null;
  let shootInterval = null;

  function init() {
    // Scene + Camera
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 12);
    camera.lookAt(0, 0, 0);

    // Renderer
    renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lighting
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(5, 10, 7);
    scene.add(dirLight);
    scene.add(new THREE.AmbientLight(0x202020));

    // Starfield
    const starGeo = new THREE.BufferGeometry();
    const starCount = 600;
    const starPos = [];
    for (let i = 0; i < starCount; i++) {
      starPos.push(
        (Math.random()*2 - 1)*80,
        (Math.random()*2 - 1)*80,
        (Math.random()*2 - 1)*-200
      );
    }
    starGeo.setAttribute('position',
      new THREE.Float32BufferAttribute(starPos, 3)
    );
    const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.7 });
    starField = new THREE.Points(starGeo, starMat);
    scene.add(starField);

    // Ship
    const shipGeo = new THREE.ConeGeometry(0.6, 1.8, 12);
    const shipMat = new THREE.MeshPhongMaterial({ color: 0x00ffff });
    ship = new THREE.Mesh(shipGeo, shipMat);
    ship.rotation.x = Math.PI/2;
    scene.add(ship);

    // Joystick Events
    const base = document.getElementById('joystickBase');
    const thumb = document.getElementById('joystickThumb');
    base.addEventListener('pointerdown', e => {
      if (pointerId !== null) return;
      pointerId = e.pointerId;
      base.setPointerCapture(pointerId);
      updateJoystick(e, base, thumb);
    });
    base.addEventListener('pointermove', e => {
      if (e.pointerId !== pointerId) return;
      updateJoystick(e, base, thumb);
    });
    base.addEventListener('pointerup', e => {
      if (e.pointerId !== pointerId) return;
      stickX = stickY = 0;
      thumb.style.transform = 'translate(0,0)';
      base.releasePointerCapture(pointerId);
      pointerId = null;
    });

    // Fire Button Events
    const fireBtn = document.getElementById('shootButton');
    fireBtn.addEventListener('pointerdown', () => {
      shoot();
      shootInterval = setInterval(shoot, 300);
    });
    fireBtn.addEventListener('pointerup', () => {
      clearInterval(shootInterval);
    });
    fireBtn.addEventListener('pointerleave', () => {
      clearInterval(shootInterval);
    });

    // Restart Button
    document.getElementById('restart')
      .addEventListener('click', () => resetGame());

    window.addEventListener('resize', onResize);
  }

  function updateJoystick(e, base, thumb) {
    const rect = base.getBoundingClientRect();
    const cx = rect.left + rect.width/2, cy = rect.top + rect.height/2;
    const dx = e.clientX - cx, dy = e.clientY - cy;
    const dist = Math.hypot(dx, dy);
    const max = rect.width/2;
    const clamped = Math.min(dist, max);
    const angle = Math.atan2(dy, dx);
    const x = Math.cos(angle)*clamped;
    const y = Math.sin(angle)*clamped;
    thumb.style.transform = `translate(${x}px, ${y}px)`;
    // normalize to [-1,1] then scale speed
    stickX = (x / max) * 0.2;
    stickY = (y / max) * 0.2;
  }

  function onResize() {
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  }

  function shoot() {
    if (gameOver) return;
    const geo = new THREE.SphereGeometry(0.1, 8, 8);
    const mat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
    const b = new THREE.Mesh(geo, mat);
    b.position.copy(ship.position).add(new THREE.Vector3(0,0,-1));
    b.userData.vel = new THREE.Vector3(0,0,-1).multiplyScalar(0.6);
    scene.add(b);
    bullets.push(b);
  }

  function spawnEnemy() {
    const r = Math.random()*0.7 + 0.3;
    const geo = new THREE.IcosahedronGeometry(r, 1);
    const mat = new THREE.MeshPhongMaterial({ color: 0xff5555, flatShading: true });
    const e = new THREE.Mesh(geo, mat);
    e.position.set((Math.random()-0.5)*10, (Math.random()-0.5)*6, -60);
    e.userData.vel = new THREE.Vector3(0,0, 0.08 + Math.random()*0.07);
    scene.add(e);
    enemies.push(e);
  }

  function updateEntities() {
    const now = performance.now();
    if (now - lastEnemyTime > 900) {
      spawnEnemy();
      lastEnemyTime = now;
    }
    // Move ship
    ship.position.x = THREE.MathUtils.clamp(ship.position.x + stickX, -6, 6);
    ship.position.y = THREE.MathUtils.clamp(ship.position.y + stickY, -4, 4);

    // Starfield rotation for depth
    starField.rotation.y += 0.0005;
    starField.rotation.x += 0.0003;

    // Bullets
    bullets = bullets.filter(b => {
      b.position.add(b.userData.vel);
      if (b.position.z < -120) {
        scene.remove(b);
        return false;
      }
      return true;
    });

    // Enemies
    enemies = enemies.filter(e => {
      e.position.add(e.userData.vel);
      if (e.position.z > 5) {
        scene.remove(e);
        hitPlayer();
        return false;
      }
      return true;
    });

    // Collisions
    bullets.forEach((b, bi) => {
      enemies.forEach((e, ei) => {
        if (b.position.distanceTo(e.position) <  r * 1.2 ) {
          scene.remove(b); scene.remove(e);
          bullets.splice(bi,1); enemies.splice(ei,1);
          score += 15; updateHUD();
        }
      });
    });
  }

  function hitPlayer() {
    health -= 25;
    updateHUD();
    if (health <= 0) endGame();
  }

  function updateHUD() {
    document.getElementById('score').textContent = 'Score: ' + score;
    document.getElementById('health').textContent = 'Health: ' + health;
  }

  function endGame() {
    gameOver = true;
    document.getElementById('gameover').style.display = 'block';
  }

  function resetGame() {
    // clean up meshes
    bullets.forEach(b=>scene.remove(b));
    enemies.forEach(e=>scene.remove(e));
    bullets = []; enemies = [];
    score = 0; health = 100; gameOver = false;
    ship.position.set(0,0,0);
    document.getElementById('gameover').style.display = 'none';
    updateHUD();
  }

  function animate() {
    requestAnimationFrame(animate);
    if (!gameOver) updateEntities();
    renderer.render(scene, camera);
  }

  // Kick things off
  init();
  animate();
  </script>
</body>
</html>