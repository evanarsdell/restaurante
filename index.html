<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <title>Ultimate 3D Shooter</title>
  <style>
    /* Basic reset */
    * { margin:0; padding:0; box-sizing:border-box; }
    html, body { width:100%; height:100%; overflow:hidden; background:#000; touch-action:none; }
    canvas { display:block; }

    /* Start & Game Over Overlays */
    .overlay {
      position:absolute; top:0; left:0; width:100%; height:100%;
      display:flex; align-items:center; justify-content:center;
      background:rgba(0,0,0,0.8); color:#fff;
      font-family:sans-serif; font-size:2rem; z-index:20;
      flex-direction:column;
    }
    #startOverlay { cursor: pointer; }
    #gameOverOverlay button {
      margin-top:1rem; padding:0.5rem 1rem;
      font-size:1rem; border:none; border-radius:5px;
      background:#f00; color:#000; cursor:pointer;
    }

    /* HUD */
    #hud {
      position:absolute; top:1rem; left:1rem;
      font-family:'Orbitron',sans-serif; color:#0f0;
      text-shadow:0 0 4px rgba(0,255,0,0.7);
      z-index:15; font-size:1rem;
    }
    #hud span { margin-right:2rem; }

    /* Joystick */
    #joystick {
      position:absolute; bottom:1rem; left:1rem;
      width:120px; height:120px; z-index:15;
    }
    #joyBase, #joyThumb {
      position:absolute; border-radius:50%; touch-action:none;
    }
    #joyBase {
      width:100%; height:100%; background:rgba(255,255,255,0.1);
      border:2px solid rgba(255,255,255,0.3);
    }
    #joyThumb {
      width:48px; height:48px; top:36px; left:36px;
      background:rgba(0,255,255,0.7);
      box-shadow:0 0 12px rgba(0,255,255,0.9);
    }

    /* Fire Button */
    #fireBtn {
      position:absolute; bottom:2rem; right:1rem;
      width:100px; height:100px; border-radius:50%;
      background:radial-gradient(circle at 30% 30%,#f00,#800);
      border:4px solid #fff; display:flex;
      align-items:center; justify-content:center;
      font-family:sans-serif; color:#fff; font-size:1rem;
      z-index:15; touch-action:none; user-select:none;
    }
    #fireBtn:active { transform:scale(0.9); }
  </style>
</head>
<body>
  <!-- Overlays -->
  <div id="startOverlay" class="overlay">
    Tap to START
  </div>
  <div id="gameOverOverlay" class="overlay" style="display:none;">
    GAME OVER
    <button id="restartBtn">Restart</button>
  </div>

  <!-- HUD -->
  <div id="hud">
    <span id="score">Score: 0</span>
    <span id="health">Health: 100</span>
  </div>

  <!-- Controls -->
  <div id="joystick">
    <div id="joyBase"></div>
    <div id="joyThumb"></div>
  </div>
  <div id="fireBtn">FIRE</div>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
  <script>
  // ——————— Object Pool Helper ———————
  class Pool {
    constructor(createFn) {
      this.createFn = createFn;
      this.items = [];
    }
    obtain() {
      return this.items.length ? this.items.pop() : this.createFn();
    }
    release(item) {
      this.items.push(item);
    }
  }

  // ——————— Bullet Class ———————
  class Bullet {
    constructor() {
      const geo = new THREE.SphereGeometry(0.1, 8, 8);
      const mat = new THREE.MeshBasicMaterial({ color:0xffff00 });
      this.mesh = new THREE.Mesh(geo, mat);
      this.vel = new THREE.Vector3(0,0,-1);
    }
    spawn(pos) {
      this.mesh.position.copy(pos);
      scene.add(this.mesh);
    }
    update(dt) {
      this.mesh.position.addScaledVector(this.vel, dt * 0.6);
      if (this.mesh.position.z < -150) return false;
      return true;
    }
    destroy() {
      scene.remove(this.mesh);
      bulletPool.release(this);
    }
  }

  // ——————— Enemy Class ———————
  class Enemy {
    constructor() {
      const baseGeo = new THREE.IcosahedronGeometry(1,1);
      const baseMat = new THREE.MeshPhongMaterial({ color:0xff5555, flatShading:true });
      this.mesh = new THREE.Mesh(baseGeo, baseMat);
      this.vel = new THREE.Vector3(0,0,1);
      this.radius = 1;
    }
    spawn() {
      const r = Math.random()*0.7 + 0.3;
      this.mesh.scale.set(r,r,r);
      this.radius = r;
      this.mesh.position.set((Math.random()-0.5)*12,(Math.random()-0.5)*8,-80);
      scene.add(this.mesh);
    }
    update(dt) {
      this.mesh.position.addScaledVector(this.vel, dt * (0.08 + Math.random()*0.07));
      if (this.mesh.position.z > 3) return false;
      return true;
    }
    destroy() {
      scene.remove(this.mesh);
      enemyPool.release(this);
    }
  }

  // ——————— Explosion Effect ———————
  class Explosion {
    constructor() {
      const geo = new THREE.SphereGeometry(1, 8,8);
      const mat = new THREE.MeshBasicMaterial({ color:0xffaa00, transparent:true, opacity:0.8 });
      this.mesh = new THREE.Mesh(geo, mat);
      this.lifetime = 0.5;
    }
    spawn(pos) {
      this.mesh.position.copy(pos);
      this.mesh.scale.set(0.2,0.2,0.2);
      this.age = 0;
      scene.add(this.mesh);
    }
    update(dt) {
      this.age += dt;
      const t = this.age / this.lifetime;
      this.mesh.scale.setScalar(0.2 + t*2);
      this.mesh.material.opacity = 0.8 * (1 - t);
      if (t >= 1) return false;
      return true;
    }
    destroy() {
      scene.remove(this.mesh);
      explosionPool.release(this);
    }
  }

  // ——————— Global Pools ———————
  const bulletPool    = new Pool(() => new Bullet());
  const enemyPool     = new Pool(() => new Enemy());
  const explosionPool = new Pool(() => new Explosion());

  // ——————— Core Setup ———————
  let scene, camera, renderer, ship, starField;
  let bullets = [], enemies = [], explosions = [];
  let lastSpawn = 0, score = 0, health = 100, gameOver = false;
  let joystick = { x:0, y:0, id:null },
      shootTouch = null, shootInterval = null;

  // ——————— Initialization ———————
  function init() {
    // Scene + Camera
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(60,innerWidth/innerHeight,0.1,500);
    camera.position.set(0,3,12);
    camera.lookAt(0,0,0);
    // Renderer
    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);
    // Lights
    const dl = new THREE.DirectionalLight(0xffffff,1);
    dl.position.set(5,10,7);
    scene.add(dl, new THREE.AmbientLight(0x202020));
    // Starfield
    const g = new THREE.BufferGeometry();
    const pts = new Float32Array(800*3);
    for (let i=0; i<800; i++) {
      pts[i*3]   = (Math.random()*2-1)*100;
      pts[i*3+1] = (Math.random()*2-1)*100;
      pts[i*3+2] = (Math.random()*2-1)*-300;
    }
    g.setAttribute('position', new THREE.BufferAttribute(pts,3));
    starField = new THREE.Points(g, new THREE.PointsMaterial({color:0xffffff, size:0.7}));
    scene.add(starField);
    // Ship
    const sGeo = new THREE.ConeGeometry(0.5,1.5,12);
    const sMat = new THREE.MeshPhongMaterial({color:0x00ffff});
    ship = new THREE.Mesh(sGeo, sMat);
    ship.rotation.x = Math.PI/2;
    scene.add(ship);

    setupControls();
    window.addEventListener('resize', onResize);
    document.getElementById('startOverlay').addEventListener('touchstart', startGame);
    document.getElementById('restartBtn').addEventListener('click', resetGame);
  }

  // ——————— Controls Setup ———————
  function setupControls() {
    const base = document.getElementById('joyBase');
    const thumb= document.getElementById('joyThumb');
    // Joystick touch
    base.addEventListener('touchstart', e=>{
      e.preventDefault();
      if (joystick.id===null) {
        const t=e.changedTouches[0];
        joystick.id=t.identifier;
        updateJoy(t);
      }
    });
    base.addEventListener('touchmove', e=>{
      e.preventDefault();
      for (let t of e.changedTouches) {
        if (t.identifier===joystick.id) { updateJoy(t); break; }
      }
    });
    base.addEventListener('touchend', e=>{
      e.preventDefault();
      for (let t of e.changedTouches) {
        if (t.identifier===joystick.id) {
          joystick.id=null; joystick.x=joystick.y=0;
          thumb.style.transform='';
        }
      }
    });

    // Fire button touch
    const fire = document.getElementById('fireBtn');
    fire.addEventListener('touchstart', e=>{
      e.preventDefault();
      const t=e.changedTouches[0];
      if (shootTouch===null) {
        shootTouch=t.identifier;
        shoot(); shootInterval=setInterval(shoot,200);
      }
    });
    fire.addEventListener('touchend', e=>{
      e.preventDefault();
      for (let t of e.changedTouches) {
        if (t.identifier===shootTouch) {
          clearInterval(shootInterval);
          shootTouch=null;
        }
      }
    });
  }

  function updateJoy(touch) {
    const rect = document.getElementById('joyBase').getBoundingClientRect();
    const dx = touch.clientX - (rect.left + rect.width/2);
    const dy = touch.clientY - (rect.top  + rect.height/2);
    const dist = Math.hypot(dx,dy), max=rect.width/2;
    const clamped = Math.min(dist, max), ang = Math.atan2(dy,dx);
    const x= Math.cos(ang)*clamped, y= Math.sin(ang)*clamped;
    document.getElementById('joyThumb')
      .style.transform = `translate(${x}px,${y}px)`;
    joystick.x = x/max;
    joystick.y = -y/max;
  }

  function startGame() {
    document.getElementById('startOverlay').style.display='none';
    lastSpawn = performance.now();
    animate();
  }

  // ——————— Game Loop ———————
  function update(dt) {
    // Ship movement
    ship.position.x = THREE.MathUtils.clamp(ship.position.x + joystick.x*dt*0.3, -8, 8);
    ship.position.y = THREE.MathUtils.clamp(ship.position.y + joystick.y*dt*0.3, -5, 5);

    // Starfield drift
    starField.rotation.y += dt*0.0004;
    starField.rotation.x += dt*0.0002;

    // Spawn difficulty scales
    if (performance.now() - lastSpawn > Math.max(200, 1000 - score*2)) {
      const e = enemyPool.obtain();
      e.spawn();
      enemies.push(e);
      lastSpawn = performance.now();
    }

    // Bullets
    for (let i=bullets.length-1; i>=0; i--) {
      if (!bullets[i].update(dt)) {
        bullets[i].destroy();
        bullets.splice(i,1);
      }
    }

    // Enemies
    for (let i=enemies.length-1; i>=0; i--) {
      if (!enemies[i].update(dt)) {
        enemies[i].destroy();
        enemies.splice(i,1);
        hitPlayer();
      }
    }

    // Collisions + Explosions
    bullets.forEach((b, bi) => {
      enemies.forEach((e, ei) => {
        if (b.mesh.position.distanceTo(e.mesh.position) < b.mesh.geometry.parameters.radius + e.radius) {
          // explosion
          const ex = explosionPool.obtain();
          ex.spawn(e.mesh.position);
          explosions.push(ex);
          // remove both
          b.destroy(); bullets.splice(bi,1);
          e.destroy(); enemies.splice(ei,1);
          // score
          score += 20; document.getElementById('score').textContent = 'Score: ' + score;
        }
      });
    });

    // Explosions
    for (let i=explosions.length-1; i>=0; i--) {
      if (!explosions[i].update(dt)) {
        explosions[i].destroy();
        explosions.splice(i,1);
      }
    }
  }

  function hitPlayer() {
    health -= 20;
    document.getElementById('health').textContent = 'Health: ' + health;
    if (health <= 0) endGame();
  }

  function shoot() {
    if (gameOver) return;
    const b = bulletPool.obtain();
    b.spawn(ship.position.clone().add(new THREE.Vector3(0,0,-1)));
    bullets.push(b);
  }

  function endGame() {
    gameOver = true;
    document.getElementById('gameOverOverlay').style.display='flex';
  }

  function resetGame() {
    // wipe everything
    bullets.forEach(b=>b.destroy()); enemies.forEach(e=>e.destroy());
    explosions.forEach(ex=>ex.destroy());
    bullets=[]; enemies=[]; explosions=[];
    score=0; health=100; gameOver=false;
    ship.position.set(0,0,0);
    document.getElementById('score').textContent = 'Score: 0';
    document.getElementById('health').textContent = 'Health: 100';
    document.getElementById('gameOverOverlay').style.display='none';
    lastSpawn = performance.now();
    animate();
  }

  let prevTime = null;
  function animate(ts) {
    if (gameOver) return;
    requestAnimationFrame(animate);
    if (!prevTime) prevTime = ts;
    const dt = (ts - prevTime) / 16.666; // normalize to ~60fps
    prevTime = ts;
    update(dt);
    renderer.render(scene, camera);
  }

  // ——————— Kickoff ———————
  init();
  </script>
</body>
</html>